# 1. Полное задание из методички с вариантом
### Задание 4: Image Segmentation (Сегментация изображений)
### Задача: реализовать простую U-Net архитектуру для сегментации изображений.
### Требования:
*- Encoder-Decoder архитектура*
*- Skip connections между encoder и decoder*
*- Dice loss функция*
### Что нужно дополнить:
// 1. Слои свёртки и пулинга
// 2. Транспонированные свёртки для upsampling
// 3. Skip connections
// 4. Dice loss и его градиент
40
Задание 5: Autoencoder для сжатия данных
Задача: создать автоэнкодер для сжатия и восстановления изображений.
Код-заготовка (Java):
class Autoencoder {
private int inputDim;
private int encodingDim;
public Autoencoder(int inputDim, int encodingDim) {
// TODO: Инициализировать encoder и decoder
// Encoder: inputDim -> encodingDim
// Decoder: encodingDim -> inputDim
public double[] encode(double[] input) {
// TODO: Сжать входные данные
public double[] decode(double[] encoded) {
// TODO: Восстановить данные
public double reconstructionLoss(double[] input, double[] reconstructed) {
// TODO: Вычислить MSE между входом и восстановленным
public void train(double[][] X, int epochs) {
// TODO: Обучить автоэнкодер
}
}
}
}
}
}
// Что нужно дополнить:
// 1. Архитектуру encoder и decoder
// 2. Функцию потерь MSE
// 3. Обучение с использованием backpropagation
// 4. Визуализацию результатов

# 2. Алгоритм работы НС по блокам
Ниже приведено пошаговое описание алгоритма работы нейросети (НС):

### Инициализация. Задаются начальные значения весов и смещений для каждого блока сети.

### Подготовка данных. 
Подготовка набора тренировочных данных и проверка данных для тестирования.
### Прямой проход (Forward Pass). 
Входные данные проходят последовательно через каждый блок сети, выполняя операции линейных преобразований и активаций. Результат последнего блока становится выходом сети.
### Вычисление ошибки.
Рассчитывается разница между ожидаемым результатом и фактическим значением выхода сети (используя выбранную функцию потери).
### Обратное распространение (Backpropagation).
Осуществляется обратный проход через сеть для вычисления производных функции потерь по каждому весу и смещению.
### Корректировка весов.
Весовые коэффициенты обновляются с использованием выбранного оптимизатора (градиентный спуск, Adam и др.).
### Проверка качества.
Периодически проверяется качество модели на тестовом наборе данных.
### Итерация. 
Повторение шагов 3-7 до достижения требуемого качества или остановочного критерия.
# 3. Ответ на контрольный вопрос
Докажите, что любой NFA может быть преобразован в эквивалентный DFA.

НФС (NFA) представляет собой автомат, допускающий неопределенность (недетерминированность) при переходе между состояниями. ДКА (DFA) является детерминированным автоматом, где каждое состояние однозначно определяет следующее состояние при любом возможном вводе.

Процесс преобразования NFA в эквивалентный DFA называется алгоритмом субсетов ("powerset construction"). Этот алгоритм работает следующим образом:

Создание стартового множества состояний DFA. Начальное состояние нового DFA формируется путем объединения всех возможных начальных состояний NFA, достижимых по пустым переходам (ε-переходы).

Формирование новых состояний DFA. Каждое новое состояние DFA соответствует подмножеству состояний NFA. Из существующего множества состояний автомата (субсета) генерируются возможные последующие множества состояний для каждого возможного символа алфавита. Эти новые множества становятся новыми состояниями DFA.

Определение перехода. Переход в новом состоянии DFA определяется как объединение всех состояний NFA, достижимых из текущего множества состояний по данному символу, включая ε-переходы.

Завершение. Продолжается построение до тех пор, пока не останется непосещенных состояний.
Таким образом, получившиеся множества состояний образуют новый DFA, эквивалентный исходному NFA, поскольку каждое состояние DFA представляет собой комбинацию состояний NFA, обеспечивая полное покрытие всех возможных путей.

Этот алгоритм доказывает, что любой NFA может быть преобразован в эквивалентный DFA.